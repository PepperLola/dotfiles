#!/bin/zsh

############## DEFAULTS ############## 

QUIET=0
DEBUG=0
BOX_WIDTH=50 # odd so controls centered
BOX_COLOR="\033[0m"
TITLE_COLOR="\033[0;35m"
TITLE_ICON_COLOR="\033[0;94m"
ARTIST_COLOR="\033[0;35m"
ARTIST_ICON_COLOR="\033[0;94m"
ALBUM_COLOR="\033[0;35m"
ALBUM_ICON_COLOR="\033[0;94m"
PLAYED_BAR_COLOR="\033[0;32m"
UNPLAYED_BAR_COLOR="\033[0;90m"
PREVIOUS_TRACK_COLOR="\033[0m"
CONTROL_HIGHLIGHT_COLOR="\033[0;101m"
PLAY_PAUSE_COLOR="\033[0m"
NEXT_TRACK_COLOR="\033[0m"
SHUFFLE_ENABLED_COLOR="\033[0;32m"
SHUFFLE_DISABLED_COLOR="\033[0;30m"
REPEAT_ENABLED_COLOR="\033[0;32m"
REPEAT_DISABLED_COLOR="\033[0;30m"

tell_cmd="tell application \"Music\" to"
function run_command() {
    echo "osascript -e '$tell_cmd $*'" | zsh
}
function init_config() {
    if [ ! -d ~/.config/music ]; then
        mkdir ~/.config/music
    fi
    if [ ! -f ~/.config/music/config.conf ]; then
        touch ~/.config/music/config.conf
        reset_config
    fi
}
function escape_colors() {
    echo $1 | sed -r "s/(\[([0-9]{1,3}(;[0-9]{1,3})?)?[m|K])/\\\\\\\\033\1/g"
}
function reset_config() {
    # this is dumb but I don't want to figure out another way
    echo """##### BEHAVIOUR #####

QUIET=$QUIET # whether to display song information after performing actions like playing, skipping, etc.
DEBUG=$DEBUG # whether to print out music track and app info from osascript

##### APPEARANCE #####

BOX_WIDTH=\"$BOX_WIDTH\" # width of interior of box

### COLORS ###

# In the form of ANSI Codes
BOX_COLOR=\"$(escape_colors $BOX_COLOR)\" # color of the box outline
TITLE_COLOR=\"$(escape_colors $TITLE_COLOR)\" # color of track title
TITLE_ICON_COLOR=\"$(escape_colors $TITLE_ICON_COLOR)\" # color of track icon
ARTIST_COLOR=\"$(escape_colors $ARTIST_COLOR)\" # color of artist name
ARTIST_ICON_COLOR=\"$(escape_colors $ARTIST_ICON_COLOR)\" # color of artist icon
ALBUM_COLOR=\"$(escape_colors $ALBUM_COLOR)\" # color of album name
ALBUM_ICON_COLOR=\"$(escape_colors $ALBUM_ICON_COLOR)\" # color of album icon
PLAYED_BAR_COLOR=\"$(escape_colors $PLAYED_BAR_COLOR)\" # color of played/elapsed part of progress bar
UNPLAYED_BAR_COLOR=\"$(escape_colors $UNPLAYED_BAR_COLOR)\" # color of unplayed part of progress bar
CONTROL_HIGHLIGHT_COLOR=\"$(escape_colors $CONTROL_HIGHLIGHT_COLOR)\" # highlight color of selected control in interactive mode
PREVIOUS_TRACK_COLOR=\"$(escape_colors $PREVIOUS_TRACK_COLOR)\" # color of previous track icon
PLAY_PAUSE_COLOR=\"$(escape_colors $PLAY_PAUSE_COLOR)\" # color of play/pause icon
NEXT_TRACK_COLOR=\"$(escape_colors $NEXT_TRACK_COLOR)\" # color of next track icon
SHUFFLE_ENABLED_COLOR=\"$(escape_colors $SHUFFLE_ENABLED_COLOR)\" # color of shuffle icon when enabled
SHUFFLE_DISABLED_COLOR=\"$(escape_colors $SHUFFLE_DISABLED_COLOR)\" # color of shuffle icon when disabled
REPEAT_ENABLED_COLOR=\"$(escape_colors $REPEAT_ENABLED_COLOR)\" # color of repeat icon when enabled
REPEAT_DISABLED_COLOR=\"$(escape_colors $REPEAT_DISABLED_COLOR)\" # color of repeat icon when disabled""" > ~/.config/music/config.conf
}
for arg in $@; do
    case $arg in
        -q|--quiet)
            QUIET=1
            ;;
        -d|--debug|--print-data)
            DEBUG=1
            ;;
        -c|--init-config)
            init_config
            ;;
        --reset-config)
            # TODO: make own confirm function
            reset_config
            # gum confirm "Are you sure you want to reset your config?" && reset_config
            ;;
        --edit-config)
            if [ ! -f ~/.config/music/config.conf ]; then
                gum confirm "No config found! Would you like to create one?" && init_config || exit 1
            fi
            $EDITOR ~/.config/music/config.conf
            exit 1
    esac
done

if [ -d ~/.config/music ]; then
    if [ -f ~/.config/music/config.conf ]; then
        source ~/.config/music/config.conf
    fi
fi

if (( ${#@} != 0 )); then
    case $1 in
        pause)
            run_command "pause"
            exit 1
            ;;
        unpause)
            run_command "play"
            if [ $QUIET = 0 ]; then
                music
            fi
            exit 1
            ;;
        playpause)
            run_command "playpause"
            if [ $QUIET = 0 ]; then
                music
            fi
            exit 1
            ;;
        skip | next)
            times=1
            if (( ${#@} > 1 )); then
                times=$2
            fi
            for i in $(seq 1 $times); do
                run_command "next track"
            done
            if [ $QUIET = 0 ]; then
                music
            fi
            exit 1
            ;;
        back | prev)
            times=1
            if (( ${#@} > 1 )); then
                times=$2
            fi
            for i in $(seq 1 $times); do
                run_command "back track"
            done
            if [ $QUIET = 0 ]; then
                music
            fi
            exit 1
            ;;
        previous)
            times=1
            if (( ${#@} > 1 )); then
                times=$2
            fi
            for i in $(seq 1 $times); do
                run_command "previous track"
            done
            if [ $QUIET = 0 ]; then
                music
            fi
            exit 1
            ;;
        play)
            if (( ${#@} < 3 )); then
                run_command "play"
            else
                if [[ $2 == "song" ]]; then
                    run_command "play the song named \"$3\"" # unsafe but I can't think of another way
                elif [[ $2 == "playlist" ]]; then
                    run_command "play the playlist named \"$3\""
                else
                    echo "Unknown option $2"
                fi
            fi
            if [ $QUIET = 0 ]; then
                music
            fi
            exit 1
            ;;
        shuffle)
            if (( ${#@} < 2 )); then
                run_command "set shuffle enabled to not shuffle enabled"
            else
                case $2 in
                    off)
                        run_command "set shuffle enabled to false"
                        ;;
                    songs)
                        run_command "set shuffle enabled to true"
                        run_command "set shuffle mode to songs"
                        ;;
                    albums)
                        run_command "set shuffle enabled to true"
                        run_command "set shuffle mode to albums"
                        ;;
                    groupings)
                        run_command "set shuffle enabled to true"
                        run_command "set shuffle mode to groupings"
                        ;;
                    *)
                        echo "Unknown shuffle option $2"
                        ;;
                esac
            fi
            exit 1
            ;;
        reshuffle)
            run_command "set shuffle enabled to false"
            run_command "set shuffle enabled to true"
            exit 1
            ;;
        repeat)
            if (( ${#@} < 2 )); then
                # default is all for toggling back on
                osascript \
                    -e 'tell application "Music"' \
                    -e 'if song repeat is all or song repeat is one then' \
                    -e 'set song repeat to off' \
                    -e 'else' \
                    -e 'set song repeat to all' \
                    -e 'end if' \
                    -e 'end tell' 
            else
                case $2 in
                    off)
                        run_command "set song repeat to off"
                        ;;
                    all)
                        run_command "set song repeat to all"
                        ;;
                    one)
                        run_command "set song repeat to one"
                        ;;
                    *)
                        echo "Unknown repeat option $2"
                        ;;
                esac
            fi
            exit 1
            ;;
        volume)
            if (( ${#@} < 2 )); then
                run_command "get sound volume"
            else
                if (( 0 > $2 || 100 < $2 )); then
                    echo "Invalid sound volume $2"
                else
                    run_command "set sound volume to $2"
                fi
            fi
            exit 1
            ;;
    esac
fi
function remove_colors() {
    echo $(echo $1 | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g")
}
function save_cover() {
    cover_dir=$(echo ~ | sed "s/\//:/g" | sed "s/://")
    osascript -ss \
              -e 'on run argv' \
              -e 'tell application "Music" to set artworkData to raw data of artwork 1 of current track' \
              -e 'set imageFile to item 1 of argv & ":cover.jpg"' \
              -e 'set outFile to open for access file imageFile with write permission' \
              -e 'write artworkData to outFile' \
              -e 'close access outFile' \
              -e 'end run' \
              -- $cover_dir
}
function display_cover() {
    save_cover
    ~/.iterm2/imgcat -H 128px ~/cover.jpg
}
function get_track_info() {
    echo $(run_command "get $1 of current track")
}
function get_all_track_properties() {
    echo $(get_track_info "properties")
}
function get_application_property() {
    echo $(run_command "get $1")
}
function get_all_application_properties() {
    echo $(get_application_property "properties")
}
function get_name() {
    echo $(echo $1 | awk 'match($0, /, name:([^:]*),/) { print substr($0, RSTART+7, RLENGTH-8) }')
}
function get_artist() {
    echo $(echo $1 | awk 'match($0, /, artist:([^:]*),/) { print substr($0, RSTART+9, RLENGTH-10) }')
}
function get_album() {
    echo $(echo $1 | awk 'match($0, /, album:([^:]*),/) { print substr($0, RSTART+8, RLENGTH-9) }')
}
function get_track_length() {
    echo $(echo $1 | awk 'match($0, /, duration:([0-9.]+)/) { print substr($0, RSTART+11, RLENGTH-11) }')
}
function get_player_position() {
    echo $(echo $1 | awk 'match($0, /, player position:([0-9.]+)/) { print substr($0, RSTART+18, RLENGTH-18) }')
}
function get_shuffle_enabled() {
    echo $(echo $1 | awk 'match($0, /, shuffle enabled:(true|false)/) { print substr($0, RSTART+18, RLENGTH-18) }')
}
function get_repeat_mode() {
    echo $(echo $1 | awk 'match($0, /, song repeat:(off|all|one)/) { print substr($0, RSTART+14, RLENGTH-14) }')
}
function get_player_state() {
    echo $(echo $1 | awk 'match($0, /, player state:(playing|paused)/) { print substr($0, RSTART+15, RLENGTH-15) }')
}
function print_progress_bar() {
    width=$2
    full=$(echo "$width - 2" | /usr/bin/bc)
    curr=$(echo "scale=2; ceil($1 / 100 * $full, 0)" | /usr/bin/bc -l)
    if (( $curr == 0 )); then
        printf $UNPLAYED_BAR_COLOR
        printf '━%.0s' $(seq 1 $width)
    elif (( $curr == $full )); then
        printf $PLAYED_BAR_COLOR
        printf '━%.0s' $(seq 1 $width)
    else
        printf $PLAYED_BAR_COLOR
        printf '━%.0s' $(seq 1 $curr)
        printf '╸'
        printf $UNPLAYED_BAR_COLOR
        printf '╺'
        printf '━%.0s' $(seq $(echo "$curr+1" | /usr/bin/bc) $full)
    fi
    printf '\033[0m'
}
function draw_box_row() {
    str=$(remove_colors $1)
    w=$(echo "$BOX_WIDTH - ${#str}" | /usr/bin/bc)
    printf "%b│ $1\033[0m" $BOX_COLOR
    printf " %.0s" $(seq 0 $(echo "$BOX_WIDTH - ${#str} - 2" | /usr/bin/bc))
    printf "%b│\n" $BOX_COLOR
}
function draw_controls() {
    spacing=3
    half=$(echo "ceil($BOX_WIDTH / 2, 0) - 1 + ($BOX_WIDTH % 2)" | /usr/bin/bc -l)
    left=$(echo "$half - $spacing - 3" | /usr/bin/bc)
    right=$(echo "$left + !($BOX_WIDTH % 2)" | /usr/bin/bc)
    printf "%b│ " $BOX_COLOR
    if [ $(get_shuffle_enabled $app_props) = "true" ]; then
        printf $SHUFFLE_ENABLED_COLOR
    else
        printf $SHUFFLE_DISABLED_COLOR
    fi
    printf "󰒟\033[0m"
    printf " %.0s" $(seq 0 $left)
    printf "󰒮"
    printf " %.0s" $(seq 2 $spacing)
    if [ $(get_player_state $app_props) = "playing" ]; then
        printf "󰏤"
    else
        printf "󰐊"
    fi
    printf " %.0s" $(seq 2 $spacing)
    printf "󰒭"
    printf " %.0s" $(seq 0 $right)
    repeat_mode=$(get_repeat_mode $app_props)
    if [ $repeat_mode = "off" ]; then
        printf $REPEAT_DISABLED_COLOR
        printf "󰑗"
    elif [ $repeat_mode = "all" ]; then
        printf $REPEAT_ENABLED_COLOR
        printf "󰑖\033[0m"
    else
        printf $REPEAT_ENABLED_COLOR
        printf "󰑘\033[0m"
    fi
    printf " %b│\n" $BOX_COLOR
}

function main() {
    track_props=$(get_all_track_properties)
    app_props=$(get_all_application_properties)
    if [ $DEBUG = 1 ]; then
        echo "TRACK:" $track_props "\n"
        echo "APP:" $app_props
    fi
    # display_cover
    player_pos=$(get_player_position $app_props)
    track_length=$(get_track_length $track_props)
    progress=$(echo "scale=2; $player_pos / $track_length * 100" | /usr/bin/bc)
    track_name=$(get_name $track_props)
    artist_name=$(get_artist $track_props)
    album_name=$(get_album $track_props)
    printf '%b╭' $BOX_COLOR
    printf '─%.0s' $(seq 1 $BOX_WIDTH)
    printf '╮\n'
    draw_box_row "$TITLE_ICON_COLOR󰝚 $TITLE_COLOR$track_name"
    draw_box_row "$ARTIST_ICON_COLOR $ARTIST_COLOR$artist_name"
    draw_box_row "$ALBUM_ICON_COLOR󰀥 $ALBUM_COLOR$album_name"
    printf "%b│" $BOX_COLOR
    print_progress_bar $progress $BOX_WIDTH
    printf "%b│\n" $BOX_COLOR
    draw_controls
    printf '%b╰' $BOX_COLOR
    printf '─%.0s' $(seq 1 $BOX_WIDTH)
    printf '╯\n'
}
main $@
